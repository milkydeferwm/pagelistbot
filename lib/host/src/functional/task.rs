//! Page List Bot task execution methods. Tasks are dispatched by task host. See `host.rs` for task host.

use std::collections::{BTreeSet, BTreeMap};

use interface::types as itypes;
use itypes::ast::*;
use itypes::site::{OutputFormat, OutputFormatSuccess};
use itypes::status::task::{PageListBotTaskQuerySummary, PageListBotTaskQueryError, PageListBotTaskQueryOutputPageSummary, PageListBotTaskQueryAnswer};
use provider::DataProvider;
use serde_json::Value;
use tracing::{event, Level};

pub(crate) type TaskError = PageListBotTaskQueryError;
pub(crate) type Answer = PageListBotTaskQueryAnswer;
pub(crate) type Summary = PageListBotTaskQuerySummary;
pub(crate) type OutputPageSummaryStatus = PageListBotTaskQueryOutputPageSummary;

/// The object that represents a single execution of a task.
#[derive(Clone)]
pub(crate) struct TaskExec<'task, P: DataProvider> {
    // Task specific
    pub id: Option<u64>,
    pub query: String,
    pub timeout: u64,
    pub query_limit: NumberOrInf<usize>,
    pub output: BTreeMap<String, OutputFormat>,
    pub eager: bool,

    // Global
    pub deny_ns: BTreeSet<i32>,
    pub header: String,

    // MediaWiki API related
    /// A MediaWiki API instance.
    /// `mwapi::Client` is just an `Arc` wrapper around an `InnerClient`,
    /// making `mwapi::Client` `Send` and `Sync` and `clone`ing a client shares the underlying `InnerClient`.
    /// The underlying `InnerClient` ensures that no API request is sent in parallel.
    pub api: mwapi::Client,
    /// A title codec. It can be constructed from a `SiteInfo` object.
    /// This object makes no web requests. It is safe to use without rate control.
    pub title_codec: mwtitle::TitleCodec,
    /// Optionally edit with `bot` flag.
    pub with_bot_flag: bool,

    // Data provider
    pub provider: &'task P,
}

impl<'task, P: DataProvider> TaskExec<'task, P> {

    /// Helper function to retrive an output page's existing contents.
    /// This function returns everything after the leading pair of `<noinclude></noinclude>` tags, if the query is successful.
    /// Otherwise it returns `None`.
    /// Errors are logged and will not propogate.
    async fn get_page_content(&self, page: &str) -> Option<String> {
        let params = Vec::from_iter([
            ("action".to_string(), "query".to_string()),
            ("prop".to_string(), "revisions".to_string()),
            ("titles".to_string(), page.to_string()),
            ("rvslots".to_string(), "*".to_string()),
            ("rvprop".to_string(), "content".to_string()),
            ("rvlimit".to_string(), "1".to_string()),
        ]);
        let contents = self.api.post(params).await;
        if contents.is_err() {
            event!(Level::WARN, page = page, error = ?contents.unwrap_err(), "cannot fetch original page contents");
            None
        } else {
            let contents: Value = contents.unwrap();
            if let Value::String(contents) = &contents["query"]["pages"][0]["revisions"][0]["slots"]["main"]["content"] {
                // The page content, when trimmed from start, should start with <noinclude>
                // If that is the case, copy everything after the first </noinclude> if it exists
                // Otherwise, just copy the whole page
                let mut body: String = String::new();
                if contents.trim_start().starts_with("<noinclude>") {
                    // If the remaining parts has a pairing </noinclude>, copy everything after the first </noinclude>
                    // Otherwise copy the whole page
                    // Cannot defend against some complicated scenarios such as </noinclude> in comments, in <nowiki> tags, etc
                    // Luckily if the original content is generated by the bot this will not be a problem
                    if let Some(offset) = contents.find("</noinclude>") {
                        body.push_str(&contents[offset + "</noinclude>".len()..]);
                    } else {
                        body.push_str(contents);
                    }
                } else {
                    body.push_str(contents);
                }
                Some(body)
            } else {
                event!(Level::WARN, page = page, error = ?contents, "cannot find page content in response");
                None
            }
        }
    }

    /// Check if a page is eligible for writing.
    /// A page is eligible if it exists, and is not a redirect and is not in denied namespace.
    /// Since the query is lazy-evaluated, it will be executed only when at least a target page is valid.
    /// If a query ends up with failure, the error is logged and `false` is returned, without propogating the error.
    async fn check_page(&self, page: &str) -> bool {
        let params = Vec::from_iter([
            ("action".to_string(), "query".to_string()),
            ("prop".to_string(), "info".to_string()),
            ("titles".to_string(), page.to_string()),
        ]);
        let page_info = self.api.post(params).await;
        if page_info.is_err() {
            event!(Level::WARN, page = page, error = ?page_info.unwrap_err(), "cannot fetch page information");
            false
        } else {
            let page_info: Value = page_info.unwrap();
            if let Value::Object(obj) = &page_info["error"] {
                event!(Level::WARN, page = page, error = ?obj, "cannot fetch page information");
                false
            } else if matches!(page_info["query"]["pages"][0]["missing"], Value::Bool(true)) {
                event!(Level::INFO, page = page, "target page does not exist, skip");
                false
            } else if matches!(page_info["query"]["pages"][0]["redirect"], Value::Bool(true)) {
                event!(Level::INFO, page = page, "target page is a redirect page, skip");
                false
            } else {
                let ns = page_info["query"]["pages"][0]["ns"].as_i64().unwrap() as i32;
                if ns < 0 || self.deny_ns.contains(&ns) {
                    event!(Level::INFO, page = page, "target page is in disallowed namespace, skip");
                    false
                } else {
                    true
                }
            }
        }
    }

    /// Parses and executes a query.
    /// The errors and warnings are formatted into strings.
    /// 
    /// This function is public so that others can make the query explicitly, instead of specifying `OutputFormat` and wait for lazy evaluation.
    pub async fn parse_and_query(&self) -> Result<Answer, TaskError> {
        use solver::Solver;

        let ast = parser::parse::<nom::error::VerboseError<nom_locate::LocatedSpan<&str>>>(&self.query)
            .map_err(|e| {
                let errors = e.errors;
                let error_msgs = errors.into_iter().map(|(input, errorkind)| {
                    let mut errstr = format!("[Ln {}, Col {}]: ", input.location_line(), input.get_utf8_column());
                    match errorkind {
                        nom::error::VerboseErrorKind::Nom(e) => errstr.push_str(&format!("{:?}", e)),
                        nom::error::VerboseErrorKind::Char(c) => errstr.push_str(&format!("expeted `{}`", c)),
                        nom::error::VerboseErrorKind::Context(s) => errstr.push_str(&format!("context error in section `{}`", s)),
                    }
                    errstr
                }).collect();
                TaskError::ParseError { msgs: error_msgs }
            })?;

        let result = {
            let solver = solver::recursive_tree::RecursiveTreeSolver::new(self.provider, self.query_limit);
            tokio::time::timeout(tokio::time::Duration::from_secs(self.timeout), solver.solve(&ast)).await
        };

        result.map_err(|_| TaskError::Timeout)?
            .map_err(|e| {
                let msg = format!("[Ln {}, Col {}] ‐ [Ln {}, Col {}]: {:}", e.node.span.begin_line, e.node.span.begin_col, e.node.span.end_line, e.node.span.end_col, e.content);
                TaskError::RuntimeError { msg }
            }).map(|ans| {
                let titles = Vec::from_iter(ans.titles.into_iter().map(|t| self.title_codec.to_pretty(&t)));
                let warnings = Vec::from_iter(ans.warnings.into_iter().map(|w| {
                    format!("[Ln {}, Col {}] ‐ [Ln {}, Col {}]: {:}", w.node.span.begin_line, w.node.span.begin_col, w.node.span.end_line, w.node.span.end_col, w.content)
                }));
                Answer { titles, warnings }
            })
    }

    /// Converts a `TaskError` into corresponding error code.
    fn make_error_code(err: &TaskError) -> &'static str {
        match err {
            TaskError::Timeout => "timeout",
            TaskError::ParseError { .. } => "parse",
            TaskError::RuntimeError { .. } => "runtime",
            // `NoQuery` is used for indicating status to caller.
            // Querying error code happens when making header.
            // Making header means query has been made. `NoQuery` is impossible.
            TaskError::NoQuery => unreachable!(),
        }
    }

    /// Make the header part of the output.
    /// A header has the following fields:
    /// * `id` (optional)
    /// * `status` the status code (success | timeout | parse | runtime)
    /// * `error1`, `error2`... list of errors
    /// * `warn1`, `warn2`... list of warns
    /// 
    /// The formatting of the header fields is handled by on-site header templates.
    fn make_header(&self, query_result: &Result<Answer, TaskError>) -> String {
        let status = match query_result {
            Ok(_) => "success",
            Err(e) => Self::make_error_code(e),
        };
        let mut params: BTreeMap<String, String> = BTreeMap::from_iter([
            ("status".to_string(), status.to_string()),
        ]);
        if let Some(id) = self.id {
            params.insert("id".to_string(), id.to_string());
        }
        // Format error and warn messages
        match query_result {
            Ok(ans) => {
                for (w, idx) in ans.warnings.iter().zip(1..) {
                    params.insert(format!("warn{}", idx), w.to_owned());
                }
            },
            Err(TaskError::ParseError { msgs }) => {
                for (w, idx) in msgs.iter().zip(1..) {
                    params.insert(format!("error{}", idx), w.to_owned());
                }
            },
            Err(TaskError::RuntimeError { msg }) => {
                params.insert("error1".to_string(), msg.to_owned());
            },
            Err(TaskError::Timeout) => {},
            // If we are making a header, we at least made a query. `NoQuery` is impossible.
            Err(TaskError::NoQuery) => unreachable!(),
        }

        // make template params string
        let params_string = params.into_iter().map(|(k, v)| format!("{k}={v}"))
            .collect::<Vec<String>>()
            .join("|");
        
        // synthesize header
        format!("<noinclude>{{{{ subst:{header} | {params_string} }}}}</noinclude>", header = self.header, params_string = params_string)
    }

    /// Make the body part of the output.
    fn make_body(&self, fmt: &OutputFormat, query_result: &Result<Answer, TaskError>) -> String {
        match query_result {
            Err(_) => fmt.fail.clone(),
            Ok(ans) => {
                if ans.titles.is_empty() { fmt.empty.clone() }
                else { self.make_body_success(&fmt.success, &ans.titles) }
            }
        }
    }

    /// This may panic if a new namespace is created, and the query result contains pages in this new namespace,
    /// and `SiteInfo` is not yet updated with the newest information.
    /// 
    /// This is considered very rare. During the creation of a `Title` object, we use the exact same title codec to decode a full title.
    /// Pages in yet-to-be-known namespaces are decoded into the main namespace and re-encoded from the main namespace, and we are safe.
    /// 
    /// Unless we construct a title directly from the namespace ID, this function won't panic.
    fn make_body_success<T: ToString>(&self, fmt: &OutputFormatSuccess, titles: &[T]) -> String {
        // `subst_wo_title` handles template substitution where no specific title is related.
        // Accepts:
        // * `$+`: total count of resulting titles.
        // * `$$`: print a single "$".
        let subst_wo_title = |template: &str| -> String {
            let mut output: String = String::new();
            let mut escape: bool = false;
            for char in template.chars() {
                if escape {
                    match char {
                        '$' => { output.push('$'); },
                        '+' => { output.push_str(&titles.len().to_string()); },
                        c => { output.push('$'); output.push(c); },
                    }
                    escape = false;
                } else if char == '$' {
                    escape = true;
                } else {
                    output.push(char);
                }
            }
            output
        };
        // `subst_with_title` handles template substitution where specific titles are in context.
        // Accepts:
        // * `$0`: full name (`namespace:page name`) of title.
        // * `$@`: current title index.
        // * `$+`: total count of resulting titles.
        // * `$$`: print a single "$".
        let subst_with_title = |template: &str, idx: usize, title: &str| -> String {
            let mut output: String = String::new();
            let mut escape: bool = false;
            for char in template.chars() {
                if escape {
                    match char {
                        '$' => { output.push('$'); },
                        '+' => { output.push_str(&titles.len().to_string()); },
                        '0' => { output.push_str(title); },
                        '@' => { output.push_str(&idx.to_string()); },
                        c => { output.push('$'); output.push(c); },
                    }
                    escape = false;
                } else if char == '$' {
                    escape = true;
                } else {
                    output.push(char);
                }
            }
            output
        };

        let mut output = String::new();
        output.push_str(&subst_wo_title(&fmt.before));
        let item_str = titles.iter()
            .enumerate()
            .map(|(idx, t)| subst_with_title(&fmt.item, idx, &t.to_string()))
            .collect::<Vec<String>>()
            .join(&fmt.between);
        output.push_str(&item_str);
        output.push_str(&subst_wo_title(&fmt.after));
        output
    }

    /// Make the edit summary of the output.
    fn make_edit_summary(&self, query_result: &Result<Answer, TaskError>) -> String {
        if let Ok(Answer {titles, warnings}) = query_result {
            let main = match titles.len() {
                0 => Some(String::from("Update query: empty")),
                1 => Some(String::from("Update query: 1 result")),
                l => Some(format!("Update query: {l} results")),
            };
            let append = match warnings.len() {
                0 => None,
                1 => Some(String::from("with 1 warning")),
                l => Some(format!("with {l} warnings")),
            };
            main.into_iter().chain(append).collect::<Vec<String>>().join(" ")
        } else {
            String::from("Update query: failure")
        }
    }

    /// Execute the task. If successful, returns the summary of the execution.
    pub async fn execute(&self, dry_run: bool) -> Summary {
        let mut output_status = BTreeMap::new();
        let mut query_result = None;

        // query for each page
        for (target, out) in &self.output {
            if self.check_page(target).await {
                if query_result.is_none() {
                    query_result = Some(self.parse_and_query().await);
                }
                let query_result = query_result.clone().unwrap();

                // stop here if we are simply dry-run.
                if dry_run {
                    output_status.insert(target.to_owned(), OutputPageSummaryStatus::Ok);
                    continue;
                }

                // continue to actually write the page.
                let mut text = self.make_header(&query_result);
                // test eager mode only when query error.
                if query_result.is_err() && (out.eager == Some(false) || (out.eager.is_none() && !self.eager)) {
                    // try get original result
                    let orig = self.get_page_content(target).await;
                    if let Some(orig) = orig {
                        text.push_str(&orig);
                    } else {
                        output_status.insert(target.to_owned(), OutputPageSummaryStatus::WriteError);
                        continue;
                    }
                } else if query_result.is_ok() || (out.eager == Some(true) || (out.eager.is_none() && self.eager)) {
                    text.push_str(&self.make_body(out, &query_result));
                } else { unreachable!() /* This is logically unreachable. Dumb rustc cannot automatically figure this out. */ }
                let summary = self.make_edit_summary(&query_result);
                let digest = format!("{:x}", md5::compute(&text));
                // make edit API call
                let mut params = Vec::from_iter([
                    ("action".to_string(), "edit".to_string()),
                    ("title".to_string(), target.to_owned()),
                    ("text".to_string(), text),
                    ("summary".to_string(), summary),
                    ("md5".to_string(), digest),
                    ("nocreate".to_string(), "1".to_string()),
                ]);
                if self.with_bot_flag {
                    params.push(("bot".to_string(), "1".to_string()))
                }
                let edit_result: Result<Value, _> = self.api.post_with_token("csrf", params).await;

                // one final logging
                if edit_result.is_err() {
                    event!(Level::WARN, page = target.as_str(), error = ?edit_result.unwrap_err(), "cannot write page");
                    output_status.insert(target.to_owned(), OutputPageSummaryStatus::WriteError);
                } else {
                    let edit_result = edit_result.unwrap();
                    if let Value::Object(obj) = &edit_result["error"] {
                        event!(Level::WARN, page = target.as_str(), error = ?obj, "cannot write page");
                        output_status.insert(target.to_owned(), OutputPageSummaryStatus::WriteError);
                    } else {
                        event!(Level::INFO, page = target.as_str(), "write successful");
                        output_status.insert(target.to_owned(), OutputPageSummaryStatus::Ok);
                    }
                }
            } else {
                output_status.insert(target.to_owned(), OutputPageSummaryStatus::Skipped);
            }
        }

        // gather query status
        let query_status = query_result.unwrap_or(Err(TaskError::NoQuery));

        Summary { query_status, output_status }
    }

}
